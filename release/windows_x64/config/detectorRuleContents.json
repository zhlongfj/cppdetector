{"AccessControlDetector":[{"msg":"不要将成员变量访问权限设置成public","priority":3,"rule":"AccessControlRuleMemberVariable"}],"ArrayDetector":[{"msg":"数组下标可能产生越界访问，请检查数组下标的最大取值是否超过了数组长度或小于0","priority":1,"rule":"ArrayRuleIndexOutOfBounds"},{"msg":"先使用下标再检查下表是否越界","priority":2,"rule":"ArrayRuleIndexUsedBeforeCheck"},{"msg":"对数组下标的保护存在缺陷，通常是漏掉了数组长度的边界值","priority":1,"rule":"ArrayRuleIndexCheckDefectively"},{"msg":"访问缓冲区越界，读写缓冲区的长度超过了缓冲区本身的大小","priority":1,"rule":"ArrayRuleBufferOverflow"},{"msg":"函数的返回值最大可能为缓冲区大小，可能造成越界","priority":1,"rule":"ArrayRuleIndexOutOfBoundsFromFunc"},{"msg":"循环语句中下标越界","priority":1,"rule":"ArrayRuleIndexOutOfBoundsInLoop"},{"msg":"memset第三个参数是要格式化的字节数，不应该为0","priority":2,"rule":"ArrayRuleMemsetZeroByte"}],"ClassDetector":[{"msg":"拷贝构造函数/赋值运算符或者移动构造函数/移动赋值运算符需要成对出现","priority":3,"rule":"VariableRulePairOfConstructorAndAssignment"}],"ConfusedDetector":[{"msg":"令人迷惑的;，可能是误输入的","priority":3,"rule":"ConfusedRuleSemicolon"},{"msg":"令人迷惑的break，可能导致循环只执行一遍","priority":3,"rule":"ConfusedRuleBreak"},{"msg":"令人迷惑的优先级，+优先级高于<<","priority":3,"rule":"ConfusedRulePriority"},{"msg":"令人迷惑的优先级，比较运算符高于赋值运算符，请确认是否需要添加括号","priority":3,"rule":"ConfusedRulePriorityWithAssignmentAndCompare"},{"msg":"令人迷惑的switch case，不是所有的case语句都有break，请确认是否遗漏","priority":3,"rule":"ConfusedRuleCaseWithoutBreak"},{"msg":"令人迷惑的switch case，switch中的代码都应该位于某个case条件中","priority":3,"rule":"ConfusedRuleStatementOutsideOfCase"},{"msg":"令人迷惑的判断条件，判断条件重复","priority":3,"rule":"ConfusedRuleConditionRepeat"},{"msg":"令人迷惑的赋值，将赋值语句放到断言或if中","priority":2,"rule":"ConfusedRuleAssignmentInAssertOrIf"},{"msg":"令人迷惑的函数返回值，返回值类型是bool，但是return语句是其他类型","priority":2,"rule":"ConfusedRuleReturnBool"},{"msg":"令人迷惑的switch，缺少default，可能遗漏场景","priority":3,"rule":"ConfusedRuleSwitchWithoutDefault"},{"msg":"令人迷惑的构造函数，带有1个参数的非显式构造函数可能导致隐性转换造成二义性","priority":3,"rule":"ConfusedRuleConstructor"},{"msg":"在判断条件中，初始化的变量与比较变量不一致，请确认是否正确","priority":3,"rule":"ConfusedRuleDiffVariableWithInitAndCondition"},{"msg":"函数有返回值，却没有处理","priority":2,"rule":"ConfusedRuleNotHandleFuncReturn"}],"DynamicDetector":[{"msg":"可能在动态库外面使用的局部静态变量, Android5.1跨so访问时，不同so会实例化一份独立的单例，导致系统存在多实例","priority":2,"rule":"DynamicRuleLocalStatic"},{"msg":"父类和子类所有成员都在头文件实现，在动态库外，进行安全转换（dynamatic_cast）时, android5.1会转换失败","priority":2,"rule":"DynamicRuleInline"}],"InlineDetector":[{"msg":"将不要将10行以上的函数定义成内联函数","priority":4,"rule":"InlineRuleTenLines"},{"msg":"不要将特殊的类方法设置为内联：构造函数，析构函数，虚函数","priority":4,"rule":"InlineRuleSpecialClassMethod"},{"msg":"不要内联包含循环或 switch 语句的函数","priority":4,"rule":"InlineRuleComplexFunction"},{"msg":"请不要将递归函数定义成内联函数","priority":4,"rule":"InlineRuleRecursion"}],"IteratorDetector":[{"msg":"容器迭代器越界","priority":1,"rule":"IteratorRuleOutOfBound"},{"msg":"解引用end()迭代器","priority":1,"rule":"IteratorRuleInvalidDereference"}],"LambdaDetector":[{"msg":"Lambda expressions cannot capture all variables by reference.","priority":3,"rule":"LambdaRuleCatchByReference"}],"LogicDetector":[{"msg":"总是为真或为假的判断条件","priority":3,"rule":"LogicRuleBaseValue"},{"msg":"总是为真或为假的逻辑运算，或同一判断条件写两遍","priority":3,"rule":"LogicRuleIncorrectOperation"},{"msg":"给自己赋值，请确认是否写错","priority":3,"rule":"LogicRuleAssignSelf"},{"msg":"std::string的find返回值应该与string::npos比较，且只能用== 或 !=，请确认是否误用","priority":2,"rule":"LogicRuleStringFind"},{"msg":"逻辑与表达式重复，请确认是否正确","priority":3,"rule":"LogicRuleExpressionRepetition"}],"LoopDetector":[{"msg":"for循环迭代变量不一致","priority":3,"rule":"LoopRuleWrongVariable"},{"msg":"for循环中的迭代变量被修改,可能超过范围,导致循环出错","priority":3,"rule":"LoopRuleOutOfBounds"},{"msg":"for循环中的迭代变量建议采用auto声明","priority":4,"rule":"LoopRuleSuggestauto"},{"msg":"for循环中的迭代变量方向是否反了","priority":3,"rule":"LoopRuleWrongStepDirection"}],"MemLeakDetector":[{"msg":"new了一个对象，忘记delete或采用free来释放内存","priority":3,"rule":"MemLeakRuleNewWithOutDelete"},{"msg":"realloc年轻人把握不住，让基础库实现者来把握","priority":3,"rule":"MemLeakRuleRealloc"},{"msg":"不建议使用malloc/free，请使用new/delete替代","priority":4,"rule":"MemLeakRuleMallocFree"},{"msg":"文件句柄泄漏","priority":3,"rule":"MemLeakRuleFileHandle"},{"msg":"如果class不会被继承，请用final修饰class；如果class会被继承，请用virtual修饰析构函数，否则delete基类指针时，不会调用子类的析构函数可能导致内存泄漏","priority":3,"rule":"MemLeakRuleDestructor"}],"OperationDetector":[{"msg":"被零除或对零求模","priority":1,"rule":"OperationRuleZeroDivision"},{"msg":"对bool进行四则运算可能会导致不可预知的结果","priority":2,"rule":"OperationRuleArithmeticWithBool"},{"msg":"取模的判断条件总是为真或为假","priority":2,"rule":"OperationRuleModule"},{"msg":"对浮点数或双精度数不能用相等或不相等来比较","priority":2,"rule":"OperationRuleFloat"},{"msg":"无符号数判断小于0，结果恒为false","priority":2,"rule":"OperationRuleUnsignedLessThanZero"},{"msg":"对负数进行位移将导致非预期结果","priority":1,"rule":"OperationRuleBitwiseShiftToNegative"},{"msg":"对bool进行位操作将导致非预期结果","priority":2,"rule":"OperationRuleBitwiseWithBool"}],"PointerDetector":[{"msg":"C++03以后，new失败会抛出异常而不是返回NULL，没有必要进行判空。","priority":2,"rule":"PointerRuleCheckAfterNew"},{"msg":"NULL将导致 C++ 中重载特性发生混乱：void foo(char*);void foo(int);","priority":4,"rule":"PointerRuleNullptr"},{"msg":"指针先判空，然后在判空作用域外解引用，因为指针判空暗示当前上下文该指针可能为空，因此建议对没有在判空作用域的指针添加判空保护。","priority":1,"rule":"PointerRuleUsedOutsideOfCheck"},{"msg":"指针先判空，然后在判空作用域内解引用。","priority":1,"rule":"PointerRuleUsedInsideOfNULLCheck"},{"msg":"部分对指针判空，而部分没有判空。","priority":1,"rule":"PointerRuleNotCheck"},{"msg":"使用未初始化的指针（野指针）。","priority":1,"rule":"PointerRuleUsedUninitialized"},{"msg":"使用空指针","priority":1,"rule":"PointerRuleUsedNull"},{"msg":"使用悬垂指针","priority":1,"rule":"PointerRuleUsedDanglingPointer"},{"msg":"表达式判空并逻辑与对指针进行解引用","priority":1,"rule":"PointerRuleIfNullDefect"},{"msg":"函数返回局部变量的地址或引用","priority":1,"rule":"PointerRuleLocalVariable"},{"msg":"函数返回值可能为空，请先判空再使用","priority":1,"rule":"PointerRuleReturnNull"}],"SingletonDetector":[{"msg":"不是线程安全的","priority":2,"rule":"SingletonRuleThreadSafety"}],"SizeofDetector":[{"msg":"数组作为函数参数，在函数内对数组变量使用sizeof获取数组占用空间大小，但是数组参数本质上是指针，返回的是指针大小，即32位下是4，64位下是8","priority":2,"rule":"SizeOfRuleFuncParameter"},{"msg":"无意义的重复使用sizeof，可能是失误造成的","priority":3,"rule":"SizeOfRuleRepetition"},{"msg":"对一个数字常量使用sizeof，请确认是否有意义","priority":3,"rule":"SizeOfRuleWithNumber"},{"msg":"对指针使用sizeof，请确认是否正确","priority":3,"rule":"SizeOfRulePointer"}],"UninitDetector":[{"msg":"基础类型变量可能未初始化，请确认（变量声明与初始化尽量在同一个语句）","priority":2,"rule":"UninitRuleVar"},{"msg":"指针未初始化，请确认（变量声明与初始化尽量在同一个语句）","priority":3,"rule":"UninitRulePointer"}],"VariableDetector":[{"msg":"静态生存周期的对象（全局变量，静态变量，静态类成员变量），都必须是POD类型(constexpr除外)。","priority":3,"rule":"VariableRuleGlobal"}]}